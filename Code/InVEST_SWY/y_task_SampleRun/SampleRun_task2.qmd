# Task 1: CRS Problem (completed)

# Error: 

## Conversion of crs of LULC introduces missing values
Error message: **ValueError: Values in the LULC raster were found that are not represented under the 'lucode' column of the Biophysical table. The missing values found in the LULC raster but not the table are: [nan]**

+ This is because `terra` automatically converts `NA` (R syntax) to `NaN` (numeric, floting point, value in C++ syntax). See this [issue](https://github.com/rspatial/terra/issues/849) for more details. 

```{r}
# /*===========================================*/
#'=  Setup =
# /*===========================================*/
library(here)
library(data.table)
library(dplyr)
library(terra)
library(exactextractr)
library(sf)
library(tmap)
library(ggplot2)
library(tidyr)

# EPSG:8857
# WGS 84 / Equal Earth Greenwich

# espg_code <- 8857
espg_code <- 6933

#/*--------------------------------*/
#' ## Path Setting
#/*--------------------------------*/
base_dt_dir <- "/Volumes/baseHD/NatCapTEEMs/GEP/GWR/Data"

tmp_save_dir <- here("Data/x_sample_data/1_task2")
```

```{r}
#| label: define-functions

# /*===========================================*/
#'=  Functions =
# /*===========================================*/
mod_na_cells <- function(x) {
  x[is.nan(x)] <- NA  # make sure NaN -> NA
  x
}

crop_mask_raster_for_aoi <- function(rast_object, bd_sf){	
	crop(
		rast_object, 
		vect(st_transform(bd_sf, crs = crs(rast_object, proj = TRUE))),
		mask = TRUE
  )
}
```


## AOI

```{r}
#| label: aoi
# === Original === # 
aoi_orig <- st_read(here("Data/x_sample_data/watershed_gura.shp"))

# aoi_orig_adj <- st_transform(aoi_orig, crs = st_crs(af_case_sf))

# === Test === #
# aoi_tg <- af_case_sf[aoi_orig_adj,]
# plot(aoi_tg$geometry)
# plot(aoi_orig_adj$geometry, add=TRUE, col="red")

st_write(
  st_transform(aoi_orig, crs = espg_code),
  # aoi_orig,
  here(tmp_save_dir, "aoi_guara_test.gpkg"),
  delete_dsn = TRUE,
  quiet = TRUE
)

aoi_test <- st_read(here(tmp_save_dir, "aoi_guara_test.gpkg"))
```

## Land Use/Land Cover

```{r}
#| label: lulc

# === Original === #
lulc_orig <- rast(here("Data/x_sample_data/land_use_gura.tif"))

unique(values(lulc_orig))
plot(lulc_orig)


#/*--------------------------------*/
#' ## Test
#/*--------------------------------*/
# === Load LULC === #
lulc_test <- 
  rast(file.path(base_dt_dir, "Raw/LULC/lulc_esa_2020.tif")) %>%
  crop_mask_raster_for_aoi(.,  aoi_test) %>%
  project(., paste0("epsg:", espg_code), method = "near") %>%
  app(., mod_na_cells)

writeRaster(
  lulc_test,
  here(tmp_save_dir, "lulc_gura_test.tif"),
  overwrite = TRUE,
  datatype  = "INT1U",  # fits 0..255
  NAflag    = 255
)

# unique(values(lulc_aoi))
```

## DEM (Works fine)
+ Should be the same crs as LULC: WGS 84 / UTM zone 37S (EPSG:32737)
+ Should be the same resolution as LULC: 15 m

```{r}
#| label: dem

# === Original === #
dem_orig <- rast(here("Data/x_sample_data/DEM_gura.tif"))

# crs(dem_orig) == crs(lulc_orig)
# res(dem_orig) == res(lulc_orig)

# === Test === #
dem_test <-
  rast(file.path(base_dt_dir, "Raw/DEM", paste0("hyd_", "af", "_dem_15s.tif"))) %>%
    crop_mask_raster_for_aoi(.,  aoi_test) %>%
    project(., paste0("epsg:", espg_code))

writeRaster(
  dem_test,
  here(tmp_save_dir, "dem_gura_test.tif"),
  overwrite = TRUE
)

plot(dem_test)

dem_test <- rast(here(tmp_save_dir, "dem_gura_test.tif"))
unique(values(dem_test))
```


## ET0 Directory (Works fine)
```{r}
#| label: et0_dir

# === Original === #
ls_files_et0_orig <- 
  list.files(
    here("Data/x_sample_data/ET0_monthly"), 
    full.names = TRUE
  )

et0_1_orig <- rast(ls_files_et0_orig[[1]])
plot(et0_1_orig)

# === Test === #
type = "mean"
which_et0 <- paste0("et0_m_", type, "_Agromet_raw_2020.tif")
et0_aoi_test <- 
  rast(file.path(base_dt_dir, "Raw/Weather", which_et0)) %>%
  crop_mask_raster_for_aoi(.,  aoi_test) %>%
  project(., paste0("epsg:", espg_code))

et0_out_file_names <- paste0(names(et0_aoi_test), ".tif")

writeRaster(
  et0_aoi_test,
  here(tmp_save_dir, "ET0_monthly_test", et0_out_file_names),
  overwrite = TRUE
)
# Test
# rast(here(tmp_save_dir, "ET0_monthly_test", out_file_names[[2]]))

# It is another way to write each layer separately
# for (i in 1:nlyr(et0_aoi_test)){
#   # i = 1
#   et0_aoi_test_i <- et0_aoi_test[[i]]

#   writeRaster(
#   et0_aoi_test,
#   here(tmp_save_dir, "ET0_monthly_test", paste0("ET0_", i, ".tif")),
#   overwrite = TRUE
#   )
# }
```


## Precipitation Directory (Works fine)
```{r}
#| label: precip_dir
# === Original === #
ls_files_precip_orig <- 
  list.files(
    here("Data/x_sample_data/Precipitation_monthly"), 
    full.names = TRUE
  )

precip_1_orig <- rast(ls_files_precip_orig[[1]])

# === Test === #
which_p <- paste0("p_m_mean_Agromet_raw_2020.tif")
p_monthly_aoi_test <- 
  rast(file.path(base_dt_dir, "Raw/Weather", which_p)) %>%
  crop_mask_raster_for_aoi(.,  aoi_test) %>%
  project(., paste0("epsg:", espg_code))

p_out_file_names <- paste0(names(p_monthly_aoi_test), ".tif")

writeRaster(
  p_monthly_aoi_test,
  here(tmp_save_dir, "Precipitation_monthly_test", p_out_file_names),
  overwrite = TRUE
)
```

## Rain Events Table
+ Create a single rain events table for the entire AOI, or for each climate zone within the AOI.

```{r}

```


## Soil Hydrologic Group (Works fine)
```{r}
#| label: soil_group

# === Original === #
soil_group_orig <- rast(here("Data/x_sample_data/soil_group_gura.tif"))
# unique(values(soil_group_orig))

plot(soil_group_orig)
unique(values(soil_group_orig))

# === Test === #
soil_group_test <- 
  rast(file.path(base_dt_dir, "Raw/Soil/hygeo_reclassed.tif")) %>%
  crop_mask_raster_for_aoi(.,  aoi_test) %>%
  project(., paste0("epsg:", espg_code), method = "near") %>%
  app(., mod_na_cells)

unique(values(soil_group_test))
plot(soil_group_test)

writeRaster(
  soil_group_test,
  here(tmp_save_dir, "soil_group_gura_test.tif"),
  overwrite = TRUE,
  datatype  = "INT1U",  # fits 0..255
  NAflag    = 255
)

test <- rast(here(tmp_save_dir, "soil_group_gura_test.tif"))
plot(soil_group_test)
unique(values(soil_group_test))

```


# Biophysical Table
+ For each LULC class in your LULC data, you need to have:
  + `lucode`: LULC code that matches the values in your LULC raster
  + `Kc_m`: Crop Evapotranspiration Coefficient for each month m (1 to 12)
  + `CN_j`: Curve Number for each each hydrologic soil group j (A, B, C, D)
    
```{r}
#| label: biophysical_table

# /*===========================================*/
#'=  Curve Number (CN) for each soil group =
# /*===========================================*/
# /*===== Data Preparation =====*/
# Load GCN250 data for curve number (250m resolution)
gcn_aoi <- 
  rast(file.path(base_dt_dir, "Raw/Biophysical_Tables/GCN250/GCN250_ARCII.tif")) %>%
  crop(., vect(st_transform(aoi_test, crs = crs(., proj = TRUE)))) %>%
  project(., paste0("epsg:", espg_code), method = "bilinear") %>%
  app(., mod_na_cells)

# Load LULC data for the same AOI
lulc_aoi <-
  rast(file.path(base_dt_dir, "Raw/LULC/lulc_esa_2020.tif")) %>%
  project(., gcn_aoi, method = "near") %>%
  app(., mod_na_cells)


# Load Soil Hydrologic Group data for the same AOI
soil_aoi <- 
  rast(file.path(base_dt_dir, "Raw/Soil/hygeo_reclassed.tif")) %>%
  project(., gcn_aoi, method = "near") %>%
  app(., mod_na_cells)

# Stack the rasters
stacked <- 
  c(
    lulc_aoi, 
    soil_aoi, 
    gcn_aoi
  )
names(stacked) <- c("lucode", "soil_group", "cn")
plot(stacked)

stacked_mask <- mask(stacked, vect(st_transform(aoi_test, crs = crs(stacked, proj = TRUE))))

plot(stacked_mask)

# /*===== Curve Number Calculation =====*/
cn_tbl_raw <- 
  data.table(values(stacked)) %>% 
  # na.omit(., cols = "lucode") %>% # remove rows with NA in "lucode"
  .[, soil_class := fcase(
    soil_group == 1, "A",
    soil_group == 2, "B",
    soil_group == 3, "C",
    soil_group == 4, "D"
  )]

cn_tbl_out <- 
  cn_tbl_raw %>%
  # Aggregate mean CN
  .[, .(
    cn = round(mean(cn, na.rm = TRUE), 1)
    ), by = .(lucode, soil_class)
  ] %>%
  # For lucode == 210, insert 100 for CN value 
  .[lucode == 210, cn := 100] %>%
  dcast(lucode ~ soil_class, value.var = "cn")  %>%
  # Rename columns to match InVEST requirements
  setnames(
    old = intersect(c("A", "B", "C", "D"), names(.)), 
    new = paste0("CN_", intersect(c("A", "B", "C", "D"), names(.)))
  ) %>%
  setnames(names(.), tolower(names(.)))


# /*===== Final Tuning =====*/
# These values will not be used in the model.
# 1. Make sure all required columns are present
required_cn_cols <- c("cn_a", "cn_b", "cn_c", "cn_d")
default_cn <- list(cn_a = 60, cn_b = 70, cn_c = 80, cn_d = 90)

for (col in required_cn_cols) {
  # col = required_cn_cols[1]
  if (!col %in% names(cn_tbl_out)) {
    cn_tbl_out[, (col) := default_cn[[col]]]
  }
}

# 2. Remove unnecessary columns
cn_tbl_out <- cn_tbl_out[, c("lucode", required_cn_cols), with = FALSE]

# 3. Make sure no missing values
# Row0wise mean across available CN columns
cn_tbl_out[, row_mean := round(rowMeans(.SD, na.rm = TRUE), 1), .SDcols = required_cn_cols]

# Fill only missing cells in each row with that row's mean
for (col in required_cn_cols) {
  cn_tbl_out[
    is.na(get(col)) & !is.na(row_mean),
    (col) := row_mean
  ]
}

#/*--------------------------------*/
#' ## Kc value for each month
#/*--------------------------------*/
# NDVI resolution is 
res(ndvi_m_aoi)

# === Load NDVI Values === #
ndvi_m_aoi <- 
  rast(file.path(base_dt_dir, paste0("Raw/NDVI/ndvi_m_", 2020, ".tif"))) %>%
  crop(., vect(st_transform(aoi_test, crs = crs(., proj = TRUE)))) %>%
  project(., lulc_aoi, method = "bilinear") %>%
  app(., mod_na_cells)

# lulc_aoi
kc_m_aoi <- 1.37 * ndvi_m_aoi - 0.069
kc_m_aoi <- clamp(kc_m_aoi, lower = 0, upper = 1.2)

# Extract zonal mean Kc per LULC and month
monthly_kc_dt <- 
  lapply(
    1:12, 
    function(i) {
      # i = 1
      kc_i <- kc_m_aoi[[i]]
      stats <- 
        zonal(kc_i, lulc_aoi, fun = "mean", digits = 3, na.rm = TRUE) %>%
        data.table()
      
      stats[, month := i] %>%
      setnames(names(.), c("lucode", "Kc", "month"))
    }
  ) %>%
  rbindlist(., use.names = TRUE) %>%
  dcast(lucode ~ month, value.var = "Kc") %>%
  setnames(
    as.character(1:12),
    paste0("Kc_", 1:12)
  )

# For crops, Kc = 1.37 * NDVI - 0.069

# /*===== Base Kc_table =====*/
dt <- 
  data.table(
    lucode = c(50, 60, 70, 190, 200, 210, 220),
    class = c("Evergreen forest","Deciduous forest","Shrublands","Urban","Bare ground","Snow/Ice","Open water")
  )

dt[, paste0("Kc_", 1:12) := {
    Kc <- 
      switch(
        class[1],
        "Evergreen forest" = rep(0.90, 12),
        "Deciduous forest" = rep(0.85, 12),  # treating deciduous similarly
        "Shrublands" = rep(0.70, 12),
        "Urban" = rep(0.475, 12), #Impervious surfaces=0, Vegerated patches = 0.7 ~ 0.9, so average is 0.475
        "Bare ground" = rep(0.20, 12),
        "Snow/Ice" = rep(0, 12),
        "Open water" = rep(1.00, 12)
      )
    as.list(Kc)
    }, by = lucode
  ] %>%
  .[, class := NULL] # Remove class column

ls_lucode <- unique(monthly_kc_dt$lucode)

kc_tbl_out <-
  rbind(
    monthly_kc_dt[!lucode %in% dt$lucode],
    dt[lucode %in% ls_lucode] # Remove class column
  )

# === Combine Tables === #
biophysical_tbl <- merge(cn_tbl_out, kc_tbl_out, by = "lucode", all = TRUE)

write.csv(
  biophysical_tbl, 
  here(tmp_save_dir, "biophysical_table_gura_test.csv"),
  row.names = FALSE,
  na = "NaN" 
)

```



## Check Results
```{r}
out_dir <- here("Data/x_sample_output/out_task2")
res_L <- rast(here(out_dir, "L_task2.tif"))
plot(res_L)
```
