---
title: "Generate Local Recharge Layer (L.tif) from InVEST SWY Outputs"
---

# Objective
+ Since InVEST 3.17.0, the SWY model does not produce the local recharge layer (L.tif) as an output.
+ But, it can be derived from other outputs. Specifically, L = P - Qf - AET (see InVEST SWY documentation).
+ This script generates L.tif for each watershed from the InVEST SWY outputs.
+ Then, the generated L.tif files for all watersheds within each continet into a single raster file.
  + This requires aligning all L.tif files to a common grid (based on the DEM).
+ Finally, the continent-level L rasters will be merged to create a single global L raster.


# Setup
```{r}
library(here)
i_am("Scr/Code/3_local_recharge.qmd")

# /*===== Load R packages =====*/
library(data.table)
library(dplyr)
library(terra)
library(sf)

library(foreach)

library(ggplot2)
library(tidyterra)

# /*===== Base path configurations =====*/
source(here("Scr/Code/0_path_config.R"))

# /*---- Path to the SWY output directory ----*/
final_swy_dir <- file.path(final_dir, "SWY")
```

# Prerequisites


```{r}
# === List of  Watersheds === #
hybas_tbl <- 
  readRDS(file.path(int_dir, "case_hybas_tbl_sf.rds")) %>%
  tidyr::unnest(cols = "tg_hybas_sf") %>%
  data.table() %>%
  .[,.(region = region_abbr, hybas_id = HYBAS_ID, geometry)]

swy_status_tbl <- 
  list.files(
    final_swy_dir, 
    pattern = "^x_output_status_.*\\.rds$", 
    full.names = TRUE
  ) %>%
  lapply(readRDS) %>%
  rbindlist() %>%
  .[, success := as.logical(success)] %>%
  .[success == TRUE, ] %>% # select only successful runs
  .[, .(region, hybas_id)]
```


# Get Local Recharge Layer
+ L = P - Qf - AET
+ For each watershed, L_man.tif will be saved in the corresponding SWY output folder.

```{r}
# /*===== Parallel Setup =====*/
library(future.apply)
plan(multicore, workers = 15)

library(progressr)
handlers("txtprogressbar")


# /*===== Run =====*/
ls_regions <- unique(swy_status_tbl$region)

for (r in ls_regions){
  # r = "na"
  message(paste0("Processing region: ", r))

  hybas_sf_r <- 
    merge(
      swy_status_tbl[region == r, ], # valid watersheds
      hybas_tbl[region == r,], # with geometry
      by = c("region", "hybas_id"), all.x = TRUE
    ) %>%
    st_as_sf()
  
  case_dt_r <- 
    tibble(
      region = r,
      hybas_id = hybas_sf_r$hybas_id,
      hybas = split(hybas_sf_r, seq(nrow(hybas_sf_r)))
    )
    
  xs <- 1:nrow(case_dt_r)

  with_progress({
    p <- progressor(along = xs)

    case_dt_r <- 
      case_dt_r %>%
      mutate(
        success := future_lapply(xs,
          \(x){
            # x = 1
            p()

            # SWY output directory for the watershed
            swy_out_dir_x <- file.path(final_swy_dir, r, case_dt_r$hybas_id[x])

            # Load required rasters
            p <- rast(file.path(swy_out_dir_x, "P.tif"))
            qf <- rast(file.path(swy_out_dir_x, "Qf.tif"))
            aet <- rast(file.path(swy_out_dir_x, "intermediate_outputs/aet.tif"))

            # Calculate Local Recharge
            catch_error <- try({
                l <- crop(p - qf - aet, case_dt_r$hybas[[x]], mask = TRUE)},
                silent = TRUE
              )
            
            if (inherits(catch_error, "try-error")){
              return(FALSE)
            } else {
              # Save Local Recharge raster
              writeRaster(
                l, 
                filename = file.path(swy_out_dir_x, "L_man.tif"),
                overwrite = TRUE
              )
              return(TRUE)
            }
          },
          future.seed = NULL
        )
      )
  })

  saveRDS(
    case_dt_r, 
    file.path(final_swy_dir, paste0("x_local_recharge_status_", r, ".rds"))
  )

  gc()
}


```


# Check Status

```{r}
# /*===== Check Local Recharge Generation Status =====*/
l_status_tbl <- 
  list.files(
    final_swy_dir, 
    pattern = "^x_local_recharge_status_.*\\.rds$",
    full.names = TRUE
  ) %>%
  lapply(readRDS) %>%
  rbindlist() %>%
  .[, `:=`(
    success = as.logical(success),
    hybas = NULL
  )]

l_status_tbl[, .(n_success = sum(success), n_total = .N), by = region][order(region)]

sum(l_status_tbl$success)
```


# Compile L Layers for All Watersheds
Make sure that L layer for a specific continent includes watersheds from all countries within the continent.

+ I found that `region` in `hybas_tbl` does not always correspond to the actual continent of the watershed. This does not affect the SWY model runs, but it is inconvenient when mapping the L layers by continent.

+ `continent` and `region_un` columns in "z_ee_r250_correspondence.gpkg" do not have correct continent names for some countries (e.g., French Guiana is assigned to "South America" instead of "Europe").
+ I need information on correspondence between country names and continents in which they are physically located.

## This part should be moved to "Prep_Watersheds.qmd"
```{r}

# /*===========================================*/
#'=  Create a correct continent and hybas_id mapping table =
# /*===========================================*/
hybas_sf <- st_as_sf(hybas_tbl)

# Use geo-information of country boundaries
ctry_bd_raw <- 
  st_read(
    here(raw_dir, "z_ee_r250_correspondence.gpkg"),
    quiet = TRUE
  ) %>%
  select(iso3c = iso3_r250_label, name_long)


# ggplot() + 
#   geom_sf(data = ctry_bd_raw, aes(fill = Continent_Name), color = "black")

url <- "https://gist.githubusercontent.com/stevewithington/20a69c0b6d2ff846ea5d35e5fc47f26c/raw/country-and-continent-codes-list-csv.csv"
ctry_info_raw <- 
  fread(
    url,
    encoding = "UTF-8",
    na.strings = c("", "NA"),
    check.names = TRUE  # safe column names if there are spaces/hyphens
  )

ctry_bd <- 
  merge(
    ctry_bd_raw, 
    ctry_info_raw[, .(Continent_Name, iso3c = Three_Letter_Country_Code)],
    by = "iso3c", all = TRUE
  ) %>%
  st_transform(st_crs(hybas_sf)) %>%
  filter(Continent_Name != "Antarctica" & !is.na(Continent_Name)) %>%
  mutate(
    region = case_when(
      Continent_Name == "Africa" ~ "af",
      Continent_Name == "Asia" ~ "as",
      Continent_Name == "Oceania" ~ "au",
      Continent_Name == "Europe" ~ "eu",
      Continent_Name == "North America" ~ "na",
      Continent_Name == "South America" ~ "sa"
    )
  )

# Remove duplicates
ctry_bd <- 
  ctry_bd %>%
  filter(!(name_long == "Armenia" & region == "as")) %>%
  filter(!(name_long == "Azerbaijan" & region == "as")) %>%
  filter(!(name_long == "Cyprus" & region == "as")) %>%
  filter(!(name_long == "Georgia" & region == "as")) %>%
  filter(!(name_long == "Russian Federation" & region == "as")) %>%
  filter(!(name_long == "Turkey" & region == "as")) %>%
  filter(!(name_long == "Kazakhstan" & region == "eu")) %>%
  filter(!(name_long == "United States Minor Outlying Islands" & region == "na"))

saveRDS(
  ctry_bd,
  file.path(int_dir, "ctry_region_boundary.rds")
)

# filter(ctry_bd, iso3c %in% ctry_bd$iso3c[duplicated(ctry_bd$iso3c)]) %>% data.frame()


# ggplot() + 
#   geom_sf(data = ctry_bd, aes(fill = region), color = "black")



#/*--------------------------------*/
#' ## Grouping watersheds by region
#/*--------------------------------*/
hybas_region_tbl <- foreach(r = unique(ctry_bd$region), .combine = rbind) %do% {
  # r = "eu"

  message(paste0("Processing region: ", r))

  tg_ctry_bd <- filter(ctry_bd, region == r)

  # ggplot() + geom_sf(data = tg_ctry_bd, aes(fill = region))

  # Identify hybas_ids within the region
  tg_hybas_sf <- 
    hybas_sf[tg_ctry_bd, ] %>%
    mutate(region = r)

  # ggplot() + 
  #   geom_sf(data = tg_ctry_bd, aes(fill = region)) +
  #   geom_sf(data = tg_hybas_sf, fill = "lightblue", alpha = 0.6, color = NA)

  return(tg_hybas_sf)
}

# Check: Any duplications?
any(duplicated(hybas_region_tbl$hybas_id)) # Yes
# Remove duplications
hybas_region_tbl <- 
  hybas_region_tbl %>%
  distinct(hybas_id, .keep_all = TRUE)
# Check: The number of hybas_ids should be the same as the original hybas_tbl
length(unique(hybas_region_tbl$hybas_id)) == nrow(hybas_tbl) # TRUE
# Check: Visualization
ggplot() + 
  geom_sf(data = hybas_region_tbl, aes(fill = region), color = NA)


saveRDS(
  hybas_region_tbl,
  file.path(int_dir, "hybas_region_tbl.rds")
)
```




```{r}
# /*===========================================*/
#'=  Preparation =
# /*===========================================*/
# /*===== Setup =====*/
# library(future.apply)
# plan(multicore, workers = 15)

library(progressr)
handlers("txtprogressbar")
# handlers(global = TRUE)

# === 1. Load watershed boundaries === #
hybas_region_tbl <- 
  readRDS(file.path(int_dir, "hybas_region_tbl.rds")) %>%
  data.table()

# === 2. Create Dave Directory === #
l_aligned_dir <- fn_gen_save_dir(final_dir,"l_aligned", return_path = TRUE)

# === 3. Find all L_man.tif files === #
ls_l_files <- 
  list.files(
    final_swy_dir, 
    pattern = "^L_man\\.tif$", 
    recursive = TRUE, 
    full.names = TRUE
  )

parent_dir <- basename(dirname(ls_l_files))


# /*===========================================*/
#'=  Run =
# /*===========================================*/

for(r in unique(hybas_region_tbl$region)){
  # r = "eu"
  message(paste0("Compiling L layers for region: ", r))

  # /*===== List of all L layers =====*/
  ls_hybas_ids <- hybas_region_tbl[region == r, hybas_id]

  ls_paths_l_tifs_r <- 
    lapply(ls_hybas_ids, function(id) ls_l_files[parent_dir == id]) %>%
    unlist()

  # === Load DEM layer as a template === #
  templ_dem <- rast(file.path(raw_dir, "DEM", paste0("hyd_", r, "_dem_15s.tif")))

  # === Generate save directory === #
  out_dir <- fn_gen_save_dir(l_aligned_dir, r, return_path = TRUE)

  # === Align all L layers to the template DEM === #
  xs <- 1:length(ls_paths_l_tifs_r)

  with_progress({
    p <- progressor(along = xs)

    ls_l_aligned <- 
      # future_lapply(xs, 
      lapply(xs, 
        \(x){
          # x = 1
          p()

          l_file = ls_paths_l_tifs_r[x]
          
          project(
            rast(l_file), 
            templ_dem,
            method = "bilinear",
            filename = file.path(out_dir, paste0("l_aligned_", basename(dirname(l_file)), ".tif")),
            overwrite = TRUE,
            align_only = TRUE
          )

          return(NULL)
        }
        # future.seed = NULL
      )
  })

  l_aligned_files <- list.files(out_dir, full.names = TRUE)

  final <-
    mosaic(
        sprc(l_aligned_files),
        fun = "max",
        filename = file.path(l_aligned_dir, paste0("l_aligned_", r, ".tif")),
        overwrite = TRUE
    )
    
  # plot(rast(file.path(l_aligned_dir, paste0("l_aligned_", r, ".tif"))))
    
  # final <- mosaic(sprc(list(templ_dem, test_dem)), fun="max", filename="final.tif", overwrite=TRUE)
}



# plot(rast(file.path(l_aligned_dir, paste0("l_aligned_", "eu", ".tif"))))


l_aligned_files <- 
  list.files(
    l_aligned_dir,
    pattern = "^l_aligned_.*\\.tif$",
    full.names = TRUE
  )

final_global_l <- 
  mosaic(
      sprc(l_aligned_files),
      fun = "max",
      filename = file.path(l_aligned_dir, "l_aligned_global.tif"),
      overwrite = TRUE
  )

# plot(final_global_l)
```


# Check

## By Region
+ af: max = 676
+ as: max = 238
+ au: max = 567
+ eu: max = 92
+ na: max = 232
+ sa: max = Inf




```{r}
l_aligned_dir <- fn_gen_save_dir(final_dir,"l_aligned", return_path = TRUE)

#/*--------------------------------*/
#' ## Check: By Region
#/*--------------------------------*/
r = "sa"
l_aligned_layer_r <- 
  rast(file.path(l_aligned_dir, paste0("l_aligned_", r, ".tif")))

summary(values(l_aligned_layer_r))

upper_bound <- quantile(
  values(l_aligned_layer_r, dataframe=FALSE), 
  probs = c(0.995, 0.99), 
  na.rm = TRUE
)

l_aligned_layer_r <- clamp(l_aligned_layer_r, lower = 0, upper = upper_bound)

ggplot() + 
  geom_spatraster(data = l_aligned_layer_r) +
  scale_fill_whitebox_c(
    palette = "muted",
    na.value = NA,
    n.breaks = 5,
    labels = scales::label_number(suffix = "mm"),
  ) +
  theme_bw()


plot(l_aligned_layer_r)

test_vals_dt <- 
  values(l_aligned_layer_r, dataframe=FALSE) %>%
  data.table() %>%
  setnames("lyr.1", "l_value")
  
summary(test_vals_dt)
quantile(test_vals_dt[["l_value"]], probs = c(0.99), na.rm = TRUE)

ggplot() + 
  geom_histogram(
    # data = test_vals_dt[l_value > 100 & l_value < 400, ],
    data = test_vals_dt,
    aes(x = l_value),
    bins = 100
  ) +
  theme_bw()

test_vals_dt[l_value == 1000,]
```




## Global
```{r}
#/*--------------------------------*/
#' ## Check: Global
#/*--------------------------------*/
l_aligned_global <- rast(file.path(l_aligned_dir, "l_aligned_global.tif"))

summary(values(l_aligned_global))

# ggplot() + 
#   geom_spatraster(data = l_aligned_global) +
#   scale_fill_whitebox_c(
#     palette = "muted",
#     na.value = NA,
#     n.breaks = 10,
#     labels = scales::label_number(suffix = "mm"),
#   )
```