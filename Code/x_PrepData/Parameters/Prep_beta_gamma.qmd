---
title: "Create a table for beta and gamma parameters for InVEST SWY model"
---

# Objective
+ Create a table for beta and gamma parameters for InVEST SWY model

# NOTE
According to [InVEST SWY documentation](https://storage.googleapis.com/releases.naturalcapitalproject.org/invest-userguide/latest/en/seasonal_water_yield.html#data-needs):

# **Beta_i Parameter (ratio, required)**: 

The proportion of the upgradient subsidy that is available for downgradient evapotranspiration. Default value: 1.

It depends on local topography and soil storage capacity—pixels with high storage or gentle slopes can use more upslope water.

Here, I, alternatively, derive beta_i parameter based on the average TWI (Topographic Wetness Index) value of the watershed.

Specifically, TWI is derived as TWI = ln(A / tan(slope)), where A is upslope contributing area in $m^2$ (= flow accumulation × cell area).

+ For very small watershed, the slope can be zero, leading to infinity TWI values. Thus, small watersheds (less than the resolution of DEM data, i.e., about 500 m x 500 m = 2500 m2)are excluded from this analysis.

+ **Gamma Parameter (ratio, required)**: The proportion of pixel local recharge that is available to downgradient pixels.Default value: 1.

There is no clear guidance on how to set this parameter. Here, I derive gamma parameter based on soil type (soil hydrologic group data). There are four soil hydrologic groups: (A) high infiltration rate, (B) moderate infiltration rate, (C) slow infiltration rate, and (D) very slow infiltration rate. I assign gamma values as follows:

+ 0.95 for group A, 0.85 for group B, 0.75 for group C, and 0.55 for group D.



# Setup

+ Two functions are defined in `x_SWY_Functions.qmd`:
  + `fn_get_gamma` to calculate gamma parameter for a given watershed
  + `get_beta_twi` to calculate Beta_i parameter for a given watershed

```{r}
library(here)
i_am("Scr/Code/x_PrepData/Parameters/Prep_beta_gamma.qmd")


# /*===== Load Functions =====*/
# Always load the updated version of the code
path_source_Rfunc <- here("Scr/Code/x_SWY_Functions.R")
if(file.exists(path_source_Rfunc)){
  file.remove(path_source_Rfunc)
}
# Create R script from qmd
quarto::qmd_to_r_script(qmd = here("Scr/Code/x_SWY_Functions.qmd"))
# Load functions
source(path_source_Rfunc)
```

# Data Preparation and Path Setting

```{r}
# /*===== Watersheds =====*/
hybas_tbl <- 
  readRDS(file.path(int_dir, "case_hybas_tbl_sf.rds")) %>%
  tidyr::unnest(cols = "tg_hybas_sf") %>%
  st_as_sf()

# format(object.size(hybas_tbl), units = "auto")

# /*===== Generate directory =====*/
param_dir <- 
  fn_gen_save_dir(
    where = int_dir,
    new_relative_dir_path = "Params",
    return_path = TRUE
  )
```

# Run (loop over regions)

```{r}
library(future.apply)
plan(multicore, workers = 20)

library(progressr)
handlers("txtprogressbar")
handlers(global = TRUE)

# /*===========================================*/
#'=  Run =
# /*===========================================*/
ls_regions <- unique(hybas_tbl$region_abbr)

for (r in ls_regions){
  # r = "af"
  message(paste0("Processing region: ", r))

  hybas_tbl_r <- hybas_tbl[hybas_tbl$region_abbr == r,]

  case_dt_r <- 
    tibble(
      region = r,
      hybas_id = hybas_tbl_r$HYBAS_ID,
      hybas = split(hybas_tbl_r, seq(nrow(hybas_tbl_r)))
    )
  
  xs <- 1:nrow(case_dt_r)

  with_progress({
    p <- progressor(along = xs)

  case_dt_r <- 
    case_dt_r %>%
    mutate(
      param_tbl = future_lapply(xs,
      # param_tbl = lapply(xs,
        \(x){
          # x = 1
          p()

          # === Compute beta_i parameter === #
          beta_i_val <- try(
            fn_get_beta_i(
              region_abbr_var = r,
              aoi_sf_var = case_dt_r$hybas[[x]]
            )
          )

          if(inherits(beta_i_val, "try-error")){
            beta_i_val <- NA
          } 

          # === Compute gamma parameter === #
          gamma_val <- try(
            fn_get_gamma(
              region_abbr_var = r,
              aoi_sf_var = case_dt_r$hybas[[x]]
            )
          )
          if(inherits(gamma_val, "try-error")){
            gamma_val <- NA
          }

          return_dt <-
            data.table(
              beta_i = beta_i_val,
              gamma = gamma_val
            )
          return(return_dt)
        },
        future.seed = NULL
      )
    )
  })

  case_dt_r <- 
    select(case_dt_r, -hybas) %>%
    tidyr::unnest(cols = c("param_tbl")) %>%
    data.table()
  
  saveRDS(
    case_dt_r,
    file.path(param_dir, paste0("beta_gamma_", r, ".rds"))
  )

  gc()
}
```


# Status Check

```{r}
beta_gamma_dt <- 
  list.files(
    file.path(param_dir),
    pattern = "^beta_gamma_.*\\.rds$",
    full.names = TRUE
  ) %>%
  lapply(readRDS) %>%
  rbindlist() %>%
  .[, success := !(is.na(beta_i) | is.na(gamma))]

beta_gamma_dt

beta_gamma_dt[, .(
  n_success = sum(success), 
  n_fail = sum(!success),
  n_total = .N
  ), by = region] %>%
  .[order(region)]


beta_gamma_dt[success == FALSE, ]

fail_cases <- 
  filter(hybas_tbl, HYBAS_ID %in% beta_gamma_dt[success == FALSE, hybas_id])
```

