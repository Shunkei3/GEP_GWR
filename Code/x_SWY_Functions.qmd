---
title: "Functions to Prepare Inputs for InVEST SWY Model"
---

# Objectives:
+ To create functions to prepare inputs for InVEST SWY model
+ To create functions to run InVEST SWY model


# Be Carful:
+ When you transform the crs of raster, method = "near" should be used for categorical data (e.g., LULC, soil type), and method = "bilinear" should be used for continuous data (e.g., DEM, ET0, precipitation).


# Tasks: 
+ This time, I will just crop the rasters for the AOI, but not mask them. 

# Setup

```{r}
#| label: load-packages
library(here)
i_am("Scr/Code/x_SWY_Functions.qmd")

library(data.table)
library(dplyr)
library(tidyr)

library(terra)
library(exactextractr)
library(sf)

library(tmap)
library(ggplot2)

# === Base path configurations === #
source(here("Scr/Code/0_path_config.R"))
```


```{r}
#| label: test-aoi
#| eval: false

# /*===========================================*/
#'= ## Test Run (This code chunk will be ignored) =
# /*===========================================*/
# /*===== AOI =====*/
# Load Watersheds
hybas_tbl <- 
  readRDS(file.path(int_dir, "case_hybas_tbl_sf.rds")) %>%
  unnest(cols = "tg_hybas_sf") %>%
  st_as_sf()

r <- "af"
hybas_tbl_r <- filter(hybas_tbl, region_abbr == r)

# === Select a watershed === #
tmp_aoi_i <- case_dt_r[1,]


```


```{r}
#| label: setup

espg_code <- 6933 # WGS 84 / NSIDC EASE-Grid 2.0 Global
year <- 2019

# /*===========================================*/
#'=  Generic Functions =
# /*===========================================*/
mod_na_cells <- function(x) {
  x[is.nan(x)] <- NA  # make sure NaN -> NA
  x
}

# crop_mask_raster_for_aoi <- function(rast_object, bd_sf){	
# 	crop(
# 		rast_object, 
# 		vect(st_transform(bd_sf, crs = crs(rast_object, proj = TRUE))),
# 		mask = TRUE
#   )
# }
```



# Checking path settings

+ Folder structure should be like this:
  + int_dir/<region_abbr>/<HYBAS_ID>/ ....
```{r}
#| label: path-setup

# Create directory to save SWY inputs
# `fn_gen_save_dir` is defined in 0_path_config.R
swy_dt_dir <- 
  fn_gen_save_dir(
    where = int_dir,
    new_relative_dir_path = "SWY_inputs",
    return_path = TRUE
  )

# if(!exists("base_p_dir")){
#   stop("base_p_dir is not set. Please set the base data directory.")
# } else {
#   message("base_p_dir is set to: ", base_p_dir)
# }

# if(!exists("int_dir")){
#   stop("int_dir is not set. Please set the base data directory.")
# } else {
#   message("int_dir is set to: ", int_dir)
# }
```



# Comprehensive function to prepare inputs for InVEST SWY model
+ This function will call other functions to prepare each input data. Each function is defined in below. 

+ If custom_aoi_provided is TRUE, use the provided `region_abbr` and `save_dir`. This option is used when testing with a custom AOI.


```{r}
#| eval: false

#/*--------------------------------*/
#' ## Test Run (This code chunk will be ignored)
#/*--------------------------------*/
# Test Run
x = 1

which_aoi <- filter(hybas_tbl_r, HYBAS_ID == "1060000010")

(which_aoi <- filter(hybas_tbl_r, HYBAS_ID == "1060000150"))


which_region <- which_aoi$region_abbr
ave_dir_return = FALSE
check_and_skip = TRUE
# If you want to test with a custom AOI, use the following two arguments
custom_aoi_provided = FALSE
custom_save_dir = NULL
```

+ If `check_and_skip` is TRUE, each input will be prepared only when it does not exist in the target directory.

```{r}
#| label: prepare-inputs

fn_comp_prep_inputs <- 
  function(
    which_region, 
    which_aoi, 
    save_dir_return = FALSE,
    check_and_skip = TRUE, 
    # If you want to test with a custom AOI, use the following two arguments
    custom_aoi_provided = FALSE, 
    custom_save_dir = NULL
  ){
  
  if(custom_aoi_provided){
    save_dir <- custom_save_dir
  } else {
    # /*===== Create a directory =====*/
    save_dir <-
      fn_gen_save_dir(
        where = swy_dt_dir, 
        new_relative_dir_path = file.path(which_region, which_aoi$HYBAS_ID),
        return_path = TRUE
      )
  }

  # /*===== Save AOI as a .gpkg file =====*/
  aoi_save_path <- file.path(save_dir, "aoi.gpkg")

  if(check_and_skip & file.exists(aoi_save_path)){
    invisible()
  } else {
    st_write(
      which_aoi,
      file.path(save_dir, "aoi.gpkg"),
      delete_dsn = TRUE,
      quiet = TRUE,
    )
  }

  # /*===== LULC (categorical) =====*/
  if(check_and_skip & file.exists(file.path(save_dir, "lulc.tif"))){
    invisible()
  } else {
    fn_get_lulc_aoi(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir
  )
  }
  
  # /*===== DEM (continuous)=====*/
  if(check_and_skip & file.exists(file.path(save_dir, "dem.tif"))){
    invisible()
  } else {
    fn_get_dem_aoi(
      region_abbr_var = which_region,
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir
    )
  }
  # NOTE: I know that aoi_sf_var has region_abbr column, but for sake of generality, I pass region_abbr_var separately. Also, by doing so, I can use this function for custom AOI that does not have region_abbr column.

  # /*===== Soil Hydrologic Group (categorical) =====*/
  if(check_and_skip & file.exists(file.path(save_dir, "soil_group.tif"))){
    invisible()
  } else {
    fn_get_soil_group_aoi(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir
    )
  }

  # /*===== Biophysical Table (csv)=====*/
  if(check_and_skip & file.exists(file.path(save_dir, "biophysical_table.csv"))){
    invisible()
  } else {
    fn_get_biophysical_table(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir
    )
  }

  # /*===== ET0 (continuous) =====*/
  if(check_and_skip & file.exists(file.path(save_dir, "ET0_monthly"))){
    invisible()
  } else {
    fn_get_monthly_et0(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir,
      type = "mean"
    )
  }

  # /*===== Precipitation (continuous) =====*/
  # Monthly Alpha Table (csv) will be created within this function.
  if(check_and_skip & file.exists(file.path(save_dir, "Precipitation_monthly"))){
    invisible()
  } else {
    fn_get_monthly_ppt(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir,
      type = "mean"
    )
  }
  
  # /*===== Climate Zone (categorical) =====*/
  if(check_and_skip & file.exists(file.path(save_dir, "climate_zone.tif"))){
    invisible()
  } else {
    fn_get_cz(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir
    )
  }

  # /*===== Rain Events Table (csv) =====*/
  # Create the table based on daily precipitation data and climate zone data
  if(check_and_skip & file.exists(file.path(save_dir, "rain_events_by_cz.csv"))){
    invisible()
  } else {
    fn_get_rain_events_tbl(
      aoi_sf_var = which_aoi,
      save_dir_var = save_dir,
      by_climate_zone = TRUE 
    )
  }

  # /*===== Parameters: Threshold Flow Accumulation, Beta_i Parameter, Gamma Prameter (csv) =====*/ 
  # These parameter will be generated separately and saved as csv files. 

  if (save_dir_return){
    return(save_dir)
  }
}
```


# LULC (categorical)
+ Make sure the missing values are coded as NA, not NaN.
  + apply `app(., mod_na_cells)` after projecting the raster.
+ Also, when saving raster, set `datatype = "INT1U"`.

```{r}
fn_get_lulc_aoi <- function(aoi_sf_var, save_dir_var){
    # aoi_sf_var <- which_aoi
    # save_dir_var <- save_dir
  
  lulc_aoi <- 
    rast(file.path(raw_dir, "LULC", paste0("lulc_esa_", year, ".tif"))) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
      mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "near") %>%
    app(., mod_na_cells)

  # unique(values(lulc_aoi))
  # plot(lulc_aoi)

  # === Save === #
  writeRaster(
    lulc_aoi,
    here(save_dir_var, "lulc.tif"),
    overwrite = TRUE,
    datatype  = "INT1U",  # fits 0..255
    NAflag    = 255
  )
}


# lulc_test <- rast(here(save_dir, "lulc.tif"))
# unique(values(lulc_test))
# plot(lulc_test)

```


# DEM (continuous)

```{r}
fn_get_dem_aoi <- function(region_abbr_var, aoi_sf_var, save_dir_var){
  # aoi_sf_var <- which_aoi
  # save_dir_var <- save_dir
  # region_abbr_var <- which_region

  dem_aoi <- 
    rast(file.path(raw_dir, "DEM", paste0("hyd_", region_abbr_var, "_dem_15s.tif"))) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
      mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)
  
  # plot(dem_aoi)

  # === Save === #
  writeRaster(
    dem_aoi,
    file.path(save_dir_var, "dem.tif"),
    overwrite = TRUE
  )
}
```


# Soil Hydrologic Group (categorical)
+ For details on the creation of `hygeo_reclassed.tif`, see `Prep_Soil.R`.

+ There options for `restuls` argument:
  + "save": save the raster to the specified directory (default)
  + "return": return the raster object, but do not save it
  + "save and return": save the raster and return the raster object


```{r}
fn_get_soil_group_aoi <- function(aoi_sf_var, save_dir_var, results = "save") {

  # === Load Soil Group === #
  soil_group_aoi <- 
    rast(file.path(raw_dir, "Soil/hygeo_reclassed.tif")) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))
      # mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "near") %>%
    app(., mod_na_cells)
  
  # plot(soil_group_aoi)
  # unique(values(soil_group_aoi))

    
  if(results == "return"){
    # === Return the result === #
    return(soil_group_aoi)

  } else if (results == "save and return"){
    # === Save and Return the result === #
    writeRaster(
      soil_group_aoi,
      here(save_dir_var, "soil_group.tif"),
      overwrite = TRUE,
      datatype  = "INT1U",  # fits 0..255
      NAflag    = 255
    )

    return(soil_group_aoi)

  } else {
    # === Save the result (default) === #
    writeRaster(
      soil_group_aoi,
      here(save_dir_var, "soil_group.tif"),
      overwrite = TRUE,
      datatype  = "INT1U",  # fits 0..255
      NAflag    = 255
    )
  }
}


# /*===== test =====*/
# soil_test <- rast(here(save_dir, "soil_group.tif"))
# unique(values(soil_test))
```

# Biophysical Table (csv)
A table mapping each LULC code to biophysical properties of the corresponding LULC class. All values in the LULC raster must have corresponding entries in this table.

A .csv (Comma Separated Value) table containing model information corresponding to each of the land use classes in the LULC raster. All LULC classes in the LULC raster MUST have corresponding values in this table. 

Each row is a land use/land cover class and columns must be named and defined as follows:

+ lucode: 
  + LULC codes from the LULC raster. Each code must be a unique integer.
+ cn_[SOIL_GROUP]:
  + Soil group code: A, B, C, D,
  + Curve number values for each combination of soil group and LULC class.
+ kc_[MONTH]:
  + Crop/vegetation coefficient (Kc) values for this LULC class in each month. 

## Curve Number (cn_[SOIL_GROUP])
+ Main Inputs:
  + LULC raster
  + Soil Hydrologic Group raster
  + GCN250 raster for Curve Number

## Kc values (kc_[MONTH])
#' It is assumed that the Kc values are constant for some LULC classes across all months. 
#' Those classes are evergreen forest, deciduous forest, shrublands, urban, bare ground, snow/ice, and open water.

+ Forests: FLUXNET shows evergreen Kc ~0.9 year-round
  + https://community.naturalcapitalproject.org/t/seasonal-water-yield-limitations/79/9
  + https://community.naturalcapitalproject.org/t/kc-crop-coefficient-for-urban-and-mining-land-cover-classes/1555
  + https://farmwest.com/climate/calculator-information/et/crop-coefficients/
  + https://ucanr.edu/site/center-landscape-urban-horticulture/turfgrass-crop-coefficients-kc
  + FAO 
+ Grass/shrub: mean Kc ~0.7 monthly
  + @Liu.etal2017: "Environmental controls on seasonal ecosystem evapotranspiration/potential evapotranspiration ratio as determined by the global eddy flux measurements"
+ Open water: FAO recommends ~0.75 average
+ Urban: blended impervious + vegetation, ~0.475 average
+ Bare ground and snow/ice: minimal ET, so low Kc

## Comprehensive function to generate biophysical table

```{r}
fn_get_biophysical_table <- function(aoi_sf_var, save_dir_var){

  # === Load LULC data === #
  # LULC data will be used to derive both Curve Number and Kc values
  lulc_aoi <- 
    rast(file.path(raw_dir, "LULC", paste0("lulc_esa_", year, ".tif"))) %>%
    crop(., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))) %>%
    project(., paste0("epsg:", espg_code), method = "near")

  #/*--------------------------------*/
  #' ## Curve Number (CN) for each soil group
  #/*--------------------------------*/
  # /*===== Data Preparation =====*/
  # Load GCN250 data for curve number (250m resolution)
  gcn_aoi <- 
    rast(file.path(raw_dir, "Biophysical_Tables/GCN250/GCN250_ARCII.tif")) %>%
    crop(., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)

  # Load LULC data for the same AOI
  lulc_aoi_gcn <-
    project(lulc_aoi, gcn_aoi, method = "near") %>%
    app(., mod_na_cells)

  # Load Soil Hydrologic Group data for the same AOI
  soil_aoi_gcn <- 
    rast(file.path(raw_dir, "Soil/hygeo_reclassed.tif")) %>%
    project(., gcn_aoi, method = "near") %>%
    app(., mod_na_cells)

  # Stack the rasters
  stacked <- c(lulc_aoi_gcn, soil_aoi_gcn, gcn_aoi)
  names(stacked) <- c("lucode", "soil_group", "cn")

  # Mask to the AOI
  stacked_mask <- mask(stacked, vect(st_transform(aoi_sf_var, crs = crs(stacked, proj = TRUE))))

  # /*===== Curve Number Calculation =====*/
  cn_tbl_raw <- 
    data.table(values(stacked)) %>% 
    # na.omit(., cols = "lucode") %>% # remove rows with NA in "lucode"
    .[, soil_class := fcase(
      soil_group == 1, "A",
      soil_group == 2, "B",
      soil_group == 3, "C",
      soil_group == 4, "D"
    )]

  cn_tbl_out <- 
    cn_tbl_raw %>%
    # Aggregate mean CN
    .[, .(
      cn = round(mean(cn, na.rm = TRUE), 1)
      ), by = .(lucode, soil_class)
    ] %>%
    # For lucode == 210, insert 100 for CN value 
    .[lucode == 210, cn := 100] %>%
    dcast(lucode ~ soil_class, value.var = "cn")  %>%
    # Rename columns to match InVEST requirements
    setnames(
      old = intersect(c("A", "B", "C", "D"), names(.)), 
      new = paste0("CN_", intersect(c("A", "B", "C", "D"), names(.)))
    ) %>%
    setnames(names(.), tolower(names(.)))

  # /*===== Final Tuning =====*/
  # These values will not be used in the model.
  # 1. Make sure all required columns are present
  required_cn_cols <- c("cn_a", "cn_b", "cn_c", "cn_d")
  default_cn <- list(cn_a = 60, cn_b = 70, cn_c = 80, cn_d = 90)

  for (col in required_cn_cols) {
    # col = required_cn_cols[1]
    if (!col %in% names(cn_tbl_out)) {
      cn_tbl_out[, (col) := default_cn[[col]]]
    }
  }

  # 2. Make sure no missing values
  # Row-wise mean across available CN columns
  cn_tbl_out[, row_mean := round(rowMeans(.SD, na.rm = TRUE), 1), .SDcols = required_cn_cols]

  # Fill only missing cells in each row with that row's mean
  for (col in required_cn_cols) {
    cn_tbl_out[
      is.na(get(col)) & !is.na(row_mean),
      (col) := row_mean
    ]
  }

  # 3. Remove unnecessary columns
  cn_tbl_out <- cn_tbl_out[, c("lucode", required_cn_cols), with = FALSE]
  # Remove rows with NA in lucode (if NA exists, the model will fail)
  cn_tbl_out <- cn_tbl_out[!is.na(lucode)]

  #/*--------------------------------*/
  #' ## Kc values (kc_[MONTH])
  #/*--------------------------------*/
  ndvi_m_aoi <- 
    rast(file.path(raw_dir, paste0("NDVI/ndvi_m_", year, ".tif"))) %>%
    crop(., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))) %>%
    project(., lulc_aoi, method = "bilinear") %>%
    app(., mod_na_cells)

  kc_m_aoi <- 1.37 * ndvi_m_aoi - 0.069
  kc_m_aoi <- clamp(kc_m_aoi, lower = 0, upper = 1.2)

  # Extract zonal mean Kc per LULC and month
  monthly_kc_dt <- 
    lapply(
      1:12, 
      function(i) {
        # i = 1
        kc_i <- kc_m_aoi[[i]]
        stats <- 
          zonal(kc_i, lulc_aoi, fun = "mean", digits = 3, na.rm = TRUE) %>%
          data.table()
        
        stats[, month := i] %>%
        setnames(names(.), c("lucode", "Kc", "month"))
      }
    ) %>%
    rbindlist(., use.names = TRUE) %>%
    dcast(lucode ~ month, value.var = "Kc") %>%
    setnames(
      as.character(1:12),
      paste0("Kc_", 1:12)
    )

  # For crops, Kc = 1.37 * NDVI - 0.069

  # /*===== Base Kc_table =====*/
  dt <- 
    data.table(
      lucode = c(50, 60, 70, 190, 200, 210, 220),
      class = c("Evergreen forest","Deciduous forest","Shrublands","Urban","Bare ground","Snow/Ice","Open water")
    )

  dt[, paste0("Kc_", 1:12) := {
      Kc <- 
        switch(
          class[1],
          "Evergreen forest" = rep(0.90, 12),
          "Deciduous forest" = rep(0.85, 12),  # treating deciduous similarly
          "Shrublands" = rep(0.70, 12),
          "Urban" = rep(0.475, 12), #Impervious surfaces=0, Vegerated patches = 0.7 ~ 0.9, so average is 0.475
          "Bare ground" = rep(0.20, 12),
          "Snow/Ice" = rep(0, 12),
          "Open water" = rep(1.00, 12)
        )
      as.list(Kc)
      }, by = lucode
    ] %>%
    .[, class := NULL] # Remove class column

  ls_lucode <- unique(monthly_kc_dt$lucode)

  kc_tbl_out <-
    rbind(
      monthly_kc_dt[!lucode %in% dt$lucode],
      dt[lucode %in% ls_lucode] # Remove class column
    )
  kc_cols <- grep("^Kc_", names(kc_tbl_out), value = TRUE)
  kc_tbl_out[, (kc_cols) := lapply(.SD, round, 2), .SDcols = kc_cols]


  #/*--------------------------------*/
  #' ## Combine CN and Kc tables to create biophysical table
  #/*--------------------------------*/ 
  biophysical_tbl <- merge(cn_tbl_out, kc_tbl_out, by = "lucode", all = TRUE)

  write.csv(
    biophysical_tbl, 
    file.path(save_dir_var, "biophysical_table.csv"),
    row.names = FALSE,
    na = "NaN" 
  )
}
```





# ET0 (continuous, (mm/month))
+ Directory containing maps of reference evapotranspiration for each month. Only .tif files should be in this folder (no .tfw, .xml, etc files). Required if User-Defined Local Recharge is not selected.

+ Reference evapotranspiration, $ET_0$, measures the amount of water that vaporizes from land into the air over a given period of time. It is the sum of evaporation (directly off of soil, bodies of water, and other surfaces) and transpiration (through plants). It is typically expressed as a depth of water in millimeters per unit time: for monthly, for annual. (Note: similar to precipitation, **this is the "depth of water that evapotranspirates from a given region; it is not "per" pixel, square meter, or any other area unit**).

+ If you are running a model that requires both precipitation and evapotranspiration as inputs, **make sure that the ET data is based on the same precipitation data that is being used as a model input**.

+ From InVEST version 3.17.0, the model accepts a csv file listing the file paths (relative to the location of the precipitation or ET0 table itself). 

+ Columns:
  + month: integer from 1 to 12
  + path to each month's raster file: path ro a precipitation or ET0 raster for that month

```{r}
fn_get_monthly_et0 <- function(aoi_sf_var, save_dir_var, type = "mean") {
  # Test Run:
  # aoi_sf_var <- hybas_tbl[1,]
  # save_dir_var <- file.path(swy_dt_dir, aoi_sf_var$region_abbr, aoi_sf_var$HYBAS_ID)
  # type <- "mean"

  et0_m_aoi <- 
    rast(file.path(raw_dir, "Weather", paste0("et0_m_", type, "_Agromet_raw_", year, ".tif"))) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))
      # mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)

  # === Save === #
  # Save each layer as a separate .tif file
  out_filenames <- paste0(names(et0_m_aoi), ".tif")

  out_file_paths <- 
    fn_gen_save_dir(
      where = save_dir_var,
      new_relative_dir_path = "ET0_monthly",
      return_path = TRUE
    )

  writeRaster(
    et0_m_aoi, 
    filename = file.path(out_file_paths, out_filenames), 
    overwrite = TRUE
  )

  # CSV table listing the file paths
  et0_path_tbl <-
    data.table(
      month = 1:12,
      path = file.path(out_file_paths, out_filenames)
    )
  
  write.csv(
    et0_path_tbl, 
    file.path(save_dir_var, "et0_path_tbl.csv"),
    row.names = FALSE,
    na = "NaN" 
  )

}
```


# Precipitation (continuous)
+ Twelve files, one for each month. File names must end with the month number (1-12). For example, the filenames ‘precip_1.tif’ and ‘precip1.tif’ are both valid names for the month of January.
+ Monthly alpha table (csv) will be created within this function.
  + "Alpha: In practice, we suggest that for highly seasonal climates, alpha should be set to the antecedent monthly precipitation values, relative to the total precipitation: Pm-1/Pannual"

```{r}
fn_get_monthly_ppt <- function(aoi_sf_var, save_dir_var, type = "mean"){
  # type = "mean"
  #/*--------------------------------*/
  #' ## Create monthly precipitation raster
  #/*--------------------------------*/
  ppt_m_aoi <- 
    rast(file.path(raw_dir, "Weather", paste0("p_m_", type, "_Agromet_raw_", year, ".tif"))) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))
      # mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)

  # === Save === #
  # Save each layer as a separate .tif file
  out_filenames <- paste0(names(ppt_m_aoi), ".tif")

  out_file_paths <- 
    fn_gen_save_dir(
      where = save_dir_var,
      new_relative_dir_path = "Precipitation_monthly",
      return_path = TRUE
    )

  writeRaster(
    ppt_m_aoi, 
    filename = file.path(out_file_paths, out_filenames), 
    overwrite = TRUE
  )

  # CSV table listing the file paths
  ppt_path_tbl <-
    data.table(
      month = 1:12,
      path = file.path(out_file_paths, out_filenames)
    )
  
  write.csv(
    ppt_path_tbl, 
    file.path(save_dir_var, "Precipitation_path_tbl.csv"),
    row.names = FALSE,
    na = "NaN" 
  )

  #/*--------------------------------*/
  #' ## Monthly Alpha Table
  #/*--------------------------------*/
  # Alpha: In practice, we suggest that for highly seasonal climates, alpha should be set to the antecedent monthly precipitation values, relative to the total precipitation: Pm-1/Pannual
  ppt_m_aoi_mask <- mask(ppt_m_aoi, aoi_sf_var)

  alpha_tbl <- 
    global(ppt_m_aoi_mask, "mean", na.rm = TRUE) %>%
    as.data.table(., keep.rownames = "month_id") %>%
    .[, month := as.integer(gsub("precip_", "", month_id))] %>%
    .[, alpha := 
      ifelse(
        month == 1, 1 / 12,
        data.table::shift(mean, type = "lag") / sum(.$mean, na.rm = TRUE)
    )]
  
  write.csv(
    alpha_tbl[, .(month, alpha)], 
    file.path(save_dir_var, "m_alpha.csv"), 
    row.names = FALSE
  )
}
```

# Climate Zone (categorical)
+ the rain events table has a count of the number of rain events per month, where each rain event exceeds 0.1mm.
+ See this: [Rain Events Table](https://community.naturalcapitalproject.org/t/rain-events-table/5488/2)

```{r}
fn_get_cz <- function(aoi_sf_var, save_dir_var){

  cz_aoi <- 
    rast(file.path(raw_dir, "ClimateZone/koppen_geiger_tif/1991_2020/koppen_geiger_0p1.tif")) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))
      # mask = TRUE 
    ) %>%
    project(., paste0("epsg:", espg_code), method = "near") %>%
    app(., mod_na_cells)

  # === Save === #
  writeRaster(
    cz_aoi,
    filename = file.path(save_dir_var, "climate_zone.tif"),
    overwrite = TRUE,
    datatype  = "INT1U",  # fits 0..255
    NAflag    = 255
  )
}

# test_cz <- rast(here(save_dir, "climate_zone.tif"))
# unique(values(test_cz))
# plot(test_cz)
```

# Rain Events Table (csv)

```{r}
fn_get_rain_events_tbl <- function(aoi_sf_var, save_dir_var, by_climate_zone = TRUE){

  # /*===== Count Rain Events =====*/
  ppt_d_event <-
    rast(file.path(raw_dir, "Weather", paste0("p_d_Argomet_raw_", year, ".tif"))) %>%
    crop(
      ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE)))
      # mask = TRUE
    ) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)
  
  ppt_d_event <- ppt_d_event > 0.1 # Logical raster
  
  # Define months for each layer
  dates <- seq.Date(as.Date(paste0(year, "-01-01")), by = "day", length.out = nlyr(ppt_d_event))
  months <- tolower(format(dates, "%b"))

  if(by_climate_zone){
    #/*--------------------------------*/
    #' ## Count Rain Events by Climate Zones in the AOI
    #/*--------------------------------*/
    cz_aoi_path <- file.path(save_dir_var, "climate_zone.tif")

    # If climate zone raster does not exist, create it
    if(!file.exists(cz_aoi_path)){
      fn_gen_climate_zone(
        aoi_sf_var = aoi_sf_var,
        save_dir_var = save_dir_var
      )
    }

    # Load Climate Zone raster
    cz_aoi <- rast(cz_aoi_path)
    # Unique climate zones in the AOI
    ls_cz_ids <- unique(cz_aoi, na.rm=TRUE)[[1]]

    res <- 
      data.table(
        cz_id = integer(),
        month = character(),
        rain_days = integer()
      )

    # Loop over climate zones
    for(cz_id in ls_cz_ids){
      # cz_id = ls_cz_ids[1]
      cz_i <- mask(cz_aoi, cz_aoi != cz_id, maskvalue = 1)

      for (m in unique(months)){
        # m = unique(months)[2]

        # Step 0: Get layers for the current month
        rain_month <- ppt_d_event[[which(months == m)]]
        # Step 1: Count rainy days at each pixel
        rain_pixel_count <- app(rain_month, fun = sum, na.rm = TRUE)
        # Step 2: Mask to current climate zone
        cz_mask_aligned <- resample(cz_i, rain_pixel_count, method = "near")
        rain_pixel_zone <- mask(rain_pixel_count, cz_mask_aligned)
        # plot(rain_pixel_zone)

        # Step 3: Aggregate all rainy days across pixels in zone
        rain_agg <- 
          global(rain_pixel_zone, "mean", na.rm = TRUE)[1, 1] %>%
          as.integer()

        # Store the result
        res <- 
          rbind(
            res, 
            data.table(
            cz_id = cz_id,
            month = m, 
            rain_days = as.integer(rain_agg))
          )
      }
    }

    res_return <- 
      dcast(res, cz_id ~ month, value.var = "rain_days") %>%
      .[, c("cz_id", tolower(month.abb)), with = FALSE]
    
    # === Save === #
    write.csv(
      res_return, 
      file.path(save_dir_var, "rain_events_by_cz.csv"), 
      row.names = FALSE
    )
    
  } else {
    #/*--------------------------------*/
    #' ## Count Rain Events for the whole AOI
    #/*--------------------------------*/
    res_return <-
      data.table(
        month = character(),
        events = integer()
      )
    
    for (m in unique(months)){
        # m = unique(months)[1]

        # Step 0: Get layers for the current month
        rain_month <- ppt_d_event[[which(months == m)]]
        # Step 1: Count rainy days at each pixel
        rain_pixel_count <- app(rain_month, fun = sum, na.rm = TRUE)
        # Step 2: Aggregate all rainy days across pixels in zone
        rain_agg <- 
          global(rain_pixel_count, "mean", na.rm = TRUE)[1, 1] %>%
          as.integer()

        # Store the result
        res_return <-
          rbind(
            res_return, 
            data.table(
              month = m, 
              events = as.integer(rain_agg)
            )
          )
    }
    res_return[, month := as.integer(match(tolower(month), tolower(month.abb)))]
    # === Save === #
    write.csv(
      res_return, 
      file.path(save_dir_var, "rain_events.csv"), 
      row.names = FALSE
    )
  }
}


# Check
# rain_event_tbl_sample <- fread()
```


# Parameters: Threshold Flow Accumulation, Beta_i Parameter, Gamma Prameter (csv)

## Threshold Flow Accumulation
+ See "Prep_FlowAcc.R" for details on how to estimate threshold flow accumulation.
+ It creates a table containing flow accumulation quantiles for each watershed in each continent.



## Beta_i Parameter

+ TWI = ln(A/tan(slope))
+ A: flow accumulation x cell area (in m2)
+ slope: slope in radians
+ Objective: Given a watershed, calculate the beta parameter as TWI (Topographic Wetness Index).

```{r}
fn_get_beta_i <- function(region_abbr_var, aoi_sf_var){
  # x = 1; aoi_sf_var <- case_dt_r$hybas[[x]]
  # x = 3; aoi_sf_var <- fail_cases[x,]
  # region_abbr_var <- aoi_sf_var$region_abbr

  # plot(st_geometry(aoi_sf_var))
  
  # /*===== Load Data =====*/
  dem_aoi <- 
      rast(file.path(raw_dir, "DEM", paste0("hyd_", region_abbr_var, "_dem_15s.tif"))) %>%
      crop(
        ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
        mask = TRUE
      ) %>%
      project(., paste0("epsg:", espg_code), method = "bilinear") %>%
      app(., mod_na_cells)
  
  # plot(dem_aoi)
  
  flow_acc <-
    rast(file.path(raw_dir, "FlowAccumulation", paste0("hyd_", region_abbr_var, "_acc_15s.tif"))) %>%
    crop(
        ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
        mask = TRUE
      ) %>%
    project(., paste0("epsg:", espg_code), method = "bilinear") %>%
    app(., mod_na_cells)

  # plot(flow_acc)
  # /*===== Slope Calculation =====*/
  slope_rad <- terrain(dem_aoi, v = "slope", unit = "radians")
    
  # Estimate cell area in m2
  res_m <- res(slope_rad)[1]  # assuming x and y resolution are equal
  cell_area <- res_m^2

  # /*===== Compute contributing area A (in m2) =====*/
  A <- flow_acc * cell_area

  # Add small epsilon to avoid division by zero
  epsilon <- 1e-6

  twi_try <- try(
    twi <- log((A + epsilon) / (tan(slope_rad) + epsilon)),
    silent = TRUE
  )

  if(inherits(twi_try, "try-error")){
    return(NA)
  }
  
  # Normalize TWI to [0, 1]
  twi_norm <- 
    (twi - global(twi, "min", na.rm = TRUE)[[1]]) / (global(twi, "max", na.rm = TRUE)[[1]] - global(twi, "min", na.rm = TRUE)[[1]])

  # plot(twi_norm)
  mean_beta_i <- 
    global(twi_norm, "mean", na.rm = TRUE)[[1]] %>%
    round(., 2)

  return(mean_beta_i)
}

# Test 
# fn_get_beta_i(region_abbr_var = "af", aoi_sf_var = case_dt_r$hybas[[1]])

```


## Gamma Parameter

+ Derive Gamma parameter based on soil type (soil hydrologic group data):
  + 1: high infiltration rate (A)
  + 2: moderate infiltration rate (B)
  + 3: slow infiltration rate (C)
  + 4: very slow infiltration rate (D)

```{r}
fn_get_gamma <- function(region_abbr_var, aoi_sf_var){
  # x = 1
  # aoi_sf_var <- case_dt_r$hybas[[x]]
  # region_abbr_var <- aoi_sf_var$region_abbr


  # === Load soil hydrologic group data === #
  path_soil_group <- file.path(int_dir, "SWY_inputs", region_abbr_var, aoi_sf_var$HYBAS_ID, "soil_group.tif")

  if(!file.exists(path_soil_group)){
    soil_aoi <- 
      fn_get_soil_group_aoi(
        aoi_sf_var = aoi_sf_var,
        save_dir_var = save_dir_var,
        results = "return"
      ) %>%
      crop(
        ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
        mask = TRUE 
      )
    # Note that if results = "return", save_dir_var is not used.

    soil_aoi <- 
      soil_aoi %>%
      crop(
        ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
        mask = TRUE 
      )
  } else {
    soil_aoi <- 
      rast(path_soil_group) %>%
      crop(
        ., vect(st_transform(aoi_sf_var, crs = crs(., proj = TRUE))),
        mask = TRUE 
      )
  }

  # plot(soil_aoi)
  
  # Count area of each soil group
  tab <- freq(soil_aoi, digits = 0)
  # Compute area fractions
  tab$area_fraction <- tab$count / sum(tab$count)

  gamma_lookup <- 
    data.frame(
      value = c(1, 2, 3, 4),
      gamma = c(0.95, 0.85, 0.75, 0.55)
    )

  # Merge lookup and compute weighted average
  tab <- merge(tab, gamma_lookup, by = "value")
  gamma_weighted <- round(sum(tab$gamma * tab$area_fraction), 2)
}
```
